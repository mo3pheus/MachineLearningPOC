package org.sanket.codingGym.iMazeForRobot.navigation;

import java.awt.Point;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

import org.sanket.codingGym.iMazeForRobot.data.Cell;
import org.sanket.codingGym.iMazeForRobot.data.Robot;

public class NavigationEngine {

	private Properties	mazeConfiguration;
	private Robot		robot;
	private Cell		destination;
	
	public NavigationEngine(Properties mazeConfig, Robot robot, Cell destination){
		mazeConfiguration = mazeConfig;
		this.robot = robot;
		this.destination = destination;
	}

	public List<Point> getRobotPath(Robot robot, Properties mazeDefinition) {
		List<Point> points = new ArrayList<Point>();
		Cell temp = new Cell(mazeDefinition);

		// move horizontally, y = robotStartLocation.y
		for (int x = robot.getLocation().x; x != temp.getLocation().x;) {
			Point tmp = new Point(x, robot.getLocation().y);
			points.add(tmp);
			x = (x < temp.getLocation().x) ? (x + 1) : (x - 1);
		}

		// move vertically, x = startPosition of temp
		for (int y = robot.getLocation().y; y != temp.getLocation().y;) {
			Point tmp = new Point(temp.getLocation().x, y);
			points.add(tmp);
			y = (y < temp.getLocation().y) ? (y + 1) : (y - 1);
		}

		try {
			Thread.sleep(20l);
			System.out.println(" Points size = " + points.size());
		} catch (Exception e) {
		}
		return points;
	}

	/**
	 * User the A* algorithm to find the path from A to B
	 * 
	 * @param robot
	 * @param destination
	 * @return
	 */
	public static List<Point> findPath(Robot robot, Cell destination) {

		return null;
	}

	/**
	 * This routine determines if there is a collision or if the path crosses
	 * walls.
	 * 
	 * @param path
	 * @return
	 */
	private boolean isPathValid(List<Point> path, Properties mazeDefinition) {
		return false;
	}
}
